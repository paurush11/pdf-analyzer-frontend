/**
 * Generated by orval v7.16.0 ðŸº
 * Do not edit manually.
 * PDF Image Analyzer API
 * API for PDF and image analysis. This OpenAPI spec can be used with Orval for frontend code generation.
 * OpenAPI spec version: v1
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import { axiosClient } from '../http';
export interface Login {
  /** @minLength 1 */
  username?: string;
  /** @minLength 1 */
  email?: string;
  /** @minLength 6 */
  password: string;
}

export interface RefreshToken {
  /** @minLength 1 */
  refreshToken: string;
  /** @minLength 1 */
  email: string;
}

export interface Signup {
  /** @minLength 1 */
  email: string;
  /** @minLength 1 */
  username: string;
  /** @minLength 6 */
  password: string;
  /** @minLength 1 */
  givenName: string;
  /** @minLength 7 */
  phone: string;
  name?: string;
}

export interface VerifyEmail {
  /** @minLength 1 */
  email?: string;
  /** @minLength 1 */
  username?: string;
  /** @minLength 1 */
  code: string;
}

export interface VerifyToken {
  /** @minLength 1 */
  token: string;
}

export type CoreAuthGoogleGoogleCallbackParams = {
/**
 * Authorization code returned by Cognito
 */
code?: string;
/**
 * OAuth error
 */
error?: string;
/**
 * OAuth error description
 */
error_description?: string;
};

/**
 * List analytics data.
 */
export const analyticsList = (
    
 signal?: AbortSignal
) => {
      
      
      return axiosClient<void>(
      {url: `/analytics/`, method: 'GET', signal
    },
      );
    }
  



export const getAnalyticsListQueryKey = () => {
    return [
    `/analytics/`
    ] as const;
    }

    
export const getAnalyticsListQueryOptions = <TData = Awaited<ReturnType<typeof analyticsList>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof analyticsList>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAnalyticsListQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof analyticsList>>> = ({ signal }) => analyticsList(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof analyticsList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type AnalyticsListQueryResult = NonNullable<Awaited<ReturnType<typeof analyticsList>>>
export type AnalyticsListQueryError = unknown


export function useAnalyticsList<TData = Awaited<ReturnType<typeof analyticsList>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof analyticsList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof analyticsList>>,
          TError,
          Awaited<ReturnType<typeof analyticsList>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAnalyticsList<TData = Awaited<ReturnType<typeof analyticsList>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof analyticsList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof analyticsList>>,
          TError,
          Awaited<ReturnType<typeof analyticsList>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAnalyticsList<TData = Awaited<ReturnType<typeof analyticsList>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof analyticsList>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useAnalyticsList<TData = Awaited<ReturnType<typeof analyticsList>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof analyticsList>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getAnalyticsListQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Create a new analytics event.
 */
export const analyticsCreate = (
    
 signal?: AbortSignal
) => {
      
      
      return axiosClient<void>(
      {url: `/analytics/`, method: 'POST', signal
    },
      );
    }
  


export const getAnalyticsCreateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof analyticsCreate>>, TError,void, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof analyticsCreate>>, TError,void, TContext> => {

const mutationKey = ['analyticsCreate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof analyticsCreate>>, void> = () => {
          

          return  analyticsCreate()
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AnalyticsCreateMutationResult = NonNullable<Awaited<ReturnType<typeof analyticsCreate>>>
    
    export type AnalyticsCreateMutationError = unknown

    export const useAnalyticsCreate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof analyticsCreate>>, TError,void, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof analyticsCreate>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getAnalyticsCreateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Get analytics summary.
 */
export const analyticsSummary = (
    
 signal?: AbortSignal
) => {
      
      
      return axiosClient<void>(
      {url: `/analytics/summary/`, method: 'GET', signal
    },
      );
    }
  



export const getAnalyticsSummaryQueryKey = () => {
    return [
    `/analytics/summary/`
    ] as const;
    }

    
export const getAnalyticsSummaryQueryOptions = <TData = Awaited<ReturnType<typeof analyticsSummary>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof analyticsSummary>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getAnalyticsSummaryQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof analyticsSummary>>> = ({ signal }) => analyticsSummary(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof analyticsSummary>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type AnalyticsSummaryQueryResult = NonNullable<Awaited<ReturnType<typeof analyticsSummary>>>
export type AnalyticsSummaryQueryError = unknown


export function useAnalyticsSummary<TData = Awaited<ReturnType<typeof analyticsSummary>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof analyticsSummary>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof analyticsSummary>>,
          TError,
          Awaited<ReturnType<typeof analyticsSummary>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAnalyticsSummary<TData = Awaited<ReturnType<typeof analyticsSummary>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof analyticsSummary>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof analyticsSummary>>,
          TError,
          Awaited<ReturnType<typeof analyticsSummary>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useAnalyticsSummary<TData = Awaited<ReturnType<typeof analyticsSummary>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof analyticsSummary>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useAnalyticsSummary<TData = Awaited<ReturnType<typeof analyticsSummary>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof analyticsSummary>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getAnalyticsSummaryQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Redirect to Cognito's /oauth2/authorize endpoint for Google OAuth.
 * @summary Initiate Google login via Cognito
 */
export const coreAuthGoogle = (
    
 signal?: AbortSignal
) => {
      
      
      return axiosClient<void>(
      {url: `/core/auth/google`, method: 'GET', signal
    },
      );
    }
  



export const getCoreAuthGoogleQueryKey = () => {
    return [
    `/core/auth/google`
    ] as const;
    }

    
export const getCoreAuthGoogleQueryOptions = <TData = Awaited<ReturnType<typeof coreAuthGoogle>>, TError = void>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof coreAuthGoogle>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCoreAuthGoogleQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof coreAuthGoogle>>> = ({ signal }) => coreAuthGoogle(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof coreAuthGoogle>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type CoreAuthGoogleQueryResult = NonNullable<Awaited<ReturnType<typeof coreAuthGoogle>>>
export type CoreAuthGoogleQueryError = void


export function useCoreAuthGoogle<TData = Awaited<ReturnType<typeof coreAuthGoogle>>, TError = void>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof coreAuthGoogle>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof coreAuthGoogle>>,
          TError,
          Awaited<ReturnType<typeof coreAuthGoogle>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCoreAuthGoogle<TData = Awaited<ReturnType<typeof coreAuthGoogle>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof coreAuthGoogle>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof coreAuthGoogle>>,
          TError,
          Awaited<ReturnType<typeof coreAuthGoogle>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCoreAuthGoogle<TData = Awaited<ReturnType<typeof coreAuthGoogle>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof coreAuthGoogle>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Initiate Google login via Cognito
 */

export function useCoreAuthGoogle<TData = Awaited<ReturnType<typeof coreAuthGoogle>>, TError = void>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof coreAuthGoogle>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCoreAuthGoogleQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Handle Google OAuth callback via Cognito (code â†’ tokens â†’ user info).
 * @summary Google OAuth callback
 */
export const coreAuthGoogleGoogleCallback = (
    params?: CoreAuthGoogleGoogleCallbackParams,
 signal?: AbortSignal
) => {
      
      
      return axiosClient<void>(
      {url: `/core/auth/google/callback`, method: 'GET',
        params, signal
    },
      );
    }
  



export const getCoreAuthGoogleGoogleCallbackQueryKey = (params?: CoreAuthGoogleGoogleCallbackParams,) => {
    return [
    `/core/auth/google/callback`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getCoreAuthGoogleGoogleCallbackQueryOptions = <TData = Awaited<ReturnType<typeof coreAuthGoogleGoogleCallback>>, TError = unknown>(params?: CoreAuthGoogleGoogleCallbackParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof coreAuthGoogleGoogleCallback>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCoreAuthGoogleGoogleCallbackQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof coreAuthGoogleGoogleCallback>>> = ({ signal }) => coreAuthGoogleGoogleCallback(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof coreAuthGoogleGoogleCallback>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type CoreAuthGoogleGoogleCallbackQueryResult = NonNullable<Awaited<ReturnType<typeof coreAuthGoogleGoogleCallback>>>
export type CoreAuthGoogleGoogleCallbackQueryError = unknown


export function useCoreAuthGoogleGoogleCallback<TData = Awaited<ReturnType<typeof coreAuthGoogleGoogleCallback>>, TError = unknown>(
 params: undefined |  CoreAuthGoogleGoogleCallbackParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof coreAuthGoogleGoogleCallback>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof coreAuthGoogleGoogleCallback>>,
          TError,
          Awaited<ReturnType<typeof coreAuthGoogleGoogleCallback>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCoreAuthGoogleGoogleCallback<TData = Awaited<ReturnType<typeof coreAuthGoogleGoogleCallback>>, TError = unknown>(
 params?: CoreAuthGoogleGoogleCallbackParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof coreAuthGoogleGoogleCallback>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof coreAuthGoogleGoogleCallback>>,
          TError,
          Awaited<ReturnType<typeof coreAuthGoogleGoogleCallback>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCoreAuthGoogleGoogleCallback<TData = Awaited<ReturnType<typeof coreAuthGoogleGoogleCallback>>, TError = unknown>(
 params?: CoreAuthGoogleGoogleCallbackParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof coreAuthGoogleGoogleCallback>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Google OAuth callback
 */

export function useCoreAuthGoogleGoogleCallback<TData = Awaited<ReturnType<typeof coreAuthGoogleGoogleCallback>>, TError = unknown>(
 params?: CoreAuthGoogleGoogleCallbackParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof coreAuthGoogleGoogleCallback>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCoreAuthGoogleGoogleCallbackQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Health check.
 * @summary Health check
 */
export const coreAuthHealth = (
    
 signal?: AbortSignal
) => {
      
      
      return axiosClient<void>(
      {url: `/core/auth/health`, method: 'GET', signal
    },
      );
    }
  



export const getCoreAuthHealthQueryKey = () => {
    return [
    `/core/auth/health`
    ] as const;
    }

    
export const getCoreAuthHealthQueryOptions = <TData = Awaited<ReturnType<typeof coreAuthHealth>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof coreAuthHealth>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getCoreAuthHealthQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof coreAuthHealth>>> = ({ signal }) => coreAuthHealth(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof coreAuthHealth>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type CoreAuthHealthQueryResult = NonNullable<Awaited<ReturnType<typeof coreAuthHealth>>>
export type CoreAuthHealthQueryError = unknown


export function useCoreAuthHealth<TData = Awaited<ReturnType<typeof coreAuthHealth>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof coreAuthHealth>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof coreAuthHealth>>,
          TError,
          Awaited<ReturnType<typeof coreAuthHealth>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCoreAuthHealth<TData = Awaited<ReturnType<typeof coreAuthHealth>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof coreAuthHealth>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof coreAuthHealth>>,
          TError,
          Awaited<ReturnType<typeof coreAuthHealth>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useCoreAuthHealth<TData = Awaited<ReturnType<typeof coreAuthHealth>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof coreAuthHealth>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Health check
 */

export function useCoreAuthHealth<TData = Awaited<ReturnType<typeof coreAuthHealth>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof coreAuthHealth>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCoreAuthHealthQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Login with username or email + password.
 * @summary Login with username or email + password
 */
export const coreAuthLogin = (
    login: Login,
 signal?: AbortSignal
) => {
      
      
      return axiosClient<void>(
      {url: `/core/auth/login`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: login, signal
    },
      );
    }
  


export const getCoreAuthLoginMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof coreAuthLogin>>, TError,{data: Login}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof coreAuthLogin>>, TError,{data: Login}, TContext> => {

const mutationKey = ['coreAuthLogin'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof coreAuthLogin>>, {data: Login}> = (props) => {
          const {data} = props ?? {};

          return  coreAuthLogin(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CoreAuthLoginMutationResult = NonNullable<Awaited<ReturnType<typeof coreAuthLogin>>>
    export type CoreAuthLoginMutationBody = Login
    export type CoreAuthLoginMutationError = unknown

    /**
 * @summary Login with username or email + password
 */
export const useCoreAuthLogin = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof coreAuthLogin>>, TError,{data: Login}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof coreAuthLogin>>,
        TError,
        {data: Login},
        TContext
      > => {

      const mutationOptions = getCoreAuthLoginMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Refresh access token.
 * @summary Refresh access token
 */
export const coreAuthRefresh = (
    refreshToken: RefreshToken,
 signal?: AbortSignal
) => {
      
      
      return axiosClient<void>(
      {url: `/core/auth/refresh`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: refreshToken, signal
    },
      );
    }
  


export const getCoreAuthRefreshMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof coreAuthRefresh>>, TError,{data: RefreshToken}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof coreAuthRefresh>>, TError,{data: RefreshToken}, TContext> => {

const mutationKey = ['coreAuthRefresh'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof coreAuthRefresh>>, {data: RefreshToken}> = (props) => {
          const {data} = props ?? {};

          return  coreAuthRefresh(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CoreAuthRefreshMutationResult = NonNullable<Awaited<ReturnType<typeof coreAuthRefresh>>>
    export type CoreAuthRefreshMutationBody = RefreshToken
    export type CoreAuthRefreshMutationError = unknown

    /**
 * @summary Refresh access token
 */
export const useCoreAuthRefresh = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof coreAuthRefresh>>, TError,{data: RefreshToken}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof coreAuthRefresh>>,
        TError,
        {data: RefreshToken},
        TContext
      > => {

      const mutationOptions = getCoreAuthRefreshMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Register a new user.
 * @summary Register (Cognito + local User)
 */
export const coreAuthSignup = (
    signup: Signup,
 signal?: AbortSignal
) => {
      
      
      return axiosClient<void>(
      {url: `/core/auth/signup`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: signup, signal
    },
      );
    }
  


export const getCoreAuthSignupMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof coreAuthSignup>>, TError,{data: Signup}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof coreAuthSignup>>, TError,{data: Signup}, TContext> => {

const mutationKey = ['coreAuthSignup'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof coreAuthSignup>>, {data: Signup}> = (props) => {
          const {data} = props ?? {};

          return  coreAuthSignup(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CoreAuthSignupMutationResult = NonNullable<Awaited<ReturnType<typeof coreAuthSignup>>>
    export type CoreAuthSignupMutationBody = Signup
    export type CoreAuthSignupMutationError = unknown

    /**
 * @summary Register (Cognito + local User)
 */
export const useCoreAuthSignup = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof coreAuthSignup>>, TError,{data: Signup}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof coreAuthSignup>>,
        TError,
        {data: Signup},
        TContext
      > => {

      const mutationOptions = getCoreAuthSignupMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Confirm email with verification code.
 * @summary Confirm email with verification code
 */
export const coreAuthVerify = (
    verifyEmail: VerifyEmail,
 signal?: AbortSignal
) => {
      
      
      return axiosClient<void>(
      {url: `/core/auth/verify`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: verifyEmail, signal
    },
      );
    }
  


export const getCoreAuthVerifyMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof coreAuthVerify>>, TError,{data: VerifyEmail}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof coreAuthVerify>>, TError,{data: VerifyEmail}, TContext> => {

const mutationKey = ['coreAuthVerify'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof coreAuthVerify>>, {data: VerifyEmail}> = (props) => {
          const {data} = props ?? {};

          return  coreAuthVerify(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CoreAuthVerifyMutationResult = NonNullable<Awaited<ReturnType<typeof coreAuthVerify>>>
    export type CoreAuthVerifyMutationBody = VerifyEmail
    export type CoreAuthVerifyMutationError = unknown

    /**
 * @summary Confirm email with verification code
 */
export const useCoreAuthVerify = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof coreAuthVerify>>, TError,{data: VerifyEmail}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof coreAuthVerify>>,
        TError,
        {data: VerifyEmail},
        TContext
      > => {

      const mutationOptions = getCoreAuthVerifyMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Verify an access token.
 * @summary Verify an access token
 */
export const coreAuthVerifyToken = (
    verifyToken: VerifyToken,
 signal?: AbortSignal
) => {
      
      
      return axiosClient<void>(
      {url: `/core/auth/verify-token`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: verifyToken, signal
    },
      );
    }
  


export const getCoreAuthVerifyTokenMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof coreAuthVerifyToken>>, TError,{data: VerifyToken}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof coreAuthVerifyToken>>, TError,{data: VerifyToken}, TContext> => {

const mutationKey = ['coreAuthVerifyToken'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof coreAuthVerifyToken>>, {data: VerifyToken}> = (props) => {
          const {data} = props ?? {};

          return  coreAuthVerifyToken(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CoreAuthVerifyTokenMutationResult = NonNullable<Awaited<ReturnType<typeof coreAuthVerifyToken>>>
    export type CoreAuthVerifyTokenMutationBody = VerifyToken
    export type CoreAuthVerifyTokenMutationError = unknown

    /**
 * @summary Verify an access token
 */
export const useCoreAuthVerifyToken = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof coreAuthVerifyToken>>, TError,{data: VerifyToken}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof coreAuthVerifyToken>>,
        TError,
        {data: VerifyToken},
        TContext
      > => {

      const mutationOptions = getCoreAuthVerifyTokenMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
export const fileUploadDownloadPresignDownload = (
    
 signal?: AbortSignal
) => {
      
      
      return axiosClient<void>(
      {url: `/file-upload/download/presign`, method: 'POST', signal
    },
      );
    }
  


export const getFileUploadDownloadPresignDownloadMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof fileUploadDownloadPresignDownload>>, TError,void, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof fileUploadDownloadPresignDownload>>, TError,void, TContext> => {

const mutationKey = ['fileUploadDownloadPresignDownload'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof fileUploadDownloadPresignDownload>>, void> = () => {
          

          return  fileUploadDownloadPresignDownload()
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type FileUploadDownloadPresignDownloadMutationResult = NonNullable<Awaited<ReturnType<typeof fileUploadDownloadPresignDownload>>>
    
    export type FileUploadDownloadPresignDownloadMutationError = unknown

    export const useFileUploadDownloadPresignDownload = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof fileUploadDownloadPresignDownload>>, TError,void, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof fileUploadDownloadPresignDownload>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getFileUploadDownloadPresignDownloadMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
export const fileUploadUploadComplete = (
    
 signal?: AbortSignal
) => {
      
      
      return axiosClient<void>(
      {url: `/file-upload/upload/complete`, method: 'POST', signal
    },
      );
    }
  


export const getFileUploadUploadCompleteMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof fileUploadUploadComplete>>, TError,void, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof fileUploadUploadComplete>>, TError,void, TContext> => {

const mutationKey = ['fileUploadUploadComplete'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof fileUploadUploadComplete>>, void> = () => {
          

          return  fileUploadUploadComplete()
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type FileUploadUploadCompleteMutationResult = NonNullable<Awaited<ReturnType<typeof fileUploadUploadComplete>>>
    
    export type FileUploadUploadCompleteMutationError = unknown

    export const useFileUploadUploadComplete = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof fileUploadUploadComplete>>, TError,void, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof fileUploadUploadComplete>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getFileUploadUploadCompleteMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
export const fileUploadUploadPlan = (
    
 signal?: AbortSignal
) => {
      
      
      return axiosClient<void>(
      {url: `/file-upload/upload/plan`, method: 'POST', signal
    },
      );
    }
  


export const getFileUploadUploadPlanMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof fileUploadUploadPlan>>, TError,void, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof fileUploadUploadPlan>>, TError,void, TContext> => {

const mutationKey = ['fileUploadUploadPlan'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof fileUploadUploadPlan>>, void> = () => {
          

          return  fileUploadUploadPlan()
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type FileUploadUploadPlanMutationResult = NonNullable<Awaited<ReturnType<typeof fileUploadUploadPlan>>>
    
    export type FileUploadUploadPlanMutationError = unknown

    export const useFileUploadUploadPlan = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof fileUploadUploadPlan>>, TError,void, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof fileUploadUploadPlan>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getFileUploadUploadPlanMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * List jobs.
 */
export const jobsList = (
    
 signal?: AbortSignal
) => {
      
      
      return axiosClient<void>(
      {url: `/jobs/`, method: 'GET', signal
    },
      );
    }
  



export const getJobsListQueryKey = () => {
    return [
    `/jobs/`
    ] as const;
    }

    
export const getJobsListQueryOptions = <TData = Awaited<ReturnType<typeof jobsList>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof jobsList>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getJobsListQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof jobsList>>> = ({ signal }) => jobsList(signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof jobsList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type JobsListQueryResult = NonNullable<Awaited<ReturnType<typeof jobsList>>>
export type JobsListQueryError = unknown


export function useJobsList<TData = Awaited<ReturnType<typeof jobsList>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof jobsList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof jobsList>>,
          TError,
          Awaited<ReturnType<typeof jobsList>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useJobsList<TData = Awaited<ReturnType<typeof jobsList>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof jobsList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof jobsList>>,
          TError,
          Awaited<ReturnType<typeof jobsList>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useJobsList<TData = Awaited<ReturnType<typeof jobsList>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof jobsList>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useJobsList<TData = Awaited<ReturnType<typeof jobsList>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof jobsList>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getJobsListQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Create a new job.
 */
export const jobsCreate = (
    
 signal?: AbortSignal
) => {
      
      
      return axiosClient<void>(
      {url: `/jobs/`, method: 'POST', signal
    },
      );
    }
  


export const getJobsCreateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof jobsCreate>>, TError,void, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof jobsCreate>>, TError,void, TContext> => {

const mutationKey = ['jobsCreate'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof jobsCreate>>, void> = () => {
          

          return  jobsCreate()
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type JobsCreateMutationResult = NonNullable<Awaited<ReturnType<typeof jobsCreate>>>
    
    export type JobsCreateMutationError = unknown

    export const useJobsCreate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof jobsCreate>>, TError,void, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof jobsCreate>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getJobsCreateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Retrieve job details.
 */
export const jobsRead = (
    id: string,
 signal?: AbortSignal
) => {
      
      
      return axiosClient<void>(
      {url: `/jobs/${id}/`, method: 'GET', signal
    },
      );
    }
  



export const getJobsReadQueryKey = (id?: string,) => {
    return [
    `/jobs/${id}/`
    ] as const;
    }

    
export const getJobsReadQueryOptions = <TData = Awaited<ReturnType<typeof jobsRead>>, TError = unknown>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof jobsRead>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getJobsReadQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof jobsRead>>> = ({ signal }) => jobsRead(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof jobsRead>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type JobsReadQueryResult = NonNullable<Awaited<ReturnType<typeof jobsRead>>>
export type JobsReadQueryError = unknown


export function useJobsRead<TData = Awaited<ReturnType<typeof jobsRead>>, TError = unknown>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof jobsRead>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof jobsRead>>,
          TError,
          Awaited<ReturnType<typeof jobsRead>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useJobsRead<TData = Awaited<ReturnType<typeof jobsRead>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof jobsRead>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof jobsRead>>,
          TError,
          Awaited<ReturnType<typeof jobsRead>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useJobsRead<TData = Awaited<ReturnType<typeof jobsRead>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof jobsRead>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useJobsRead<TData = Awaited<ReturnType<typeof jobsRead>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof jobsRead>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getJobsReadQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Get job status.
 */
export const jobsStatus = (
    id: string,
 signal?: AbortSignal
) => {
      
      
      return axiosClient<void>(
      {url: `/jobs/${id}/status/`, method: 'GET', signal
    },
      );
    }
  



export const getJobsStatusQueryKey = (id?: string,) => {
    return [
    `/jobs/${id}/status/`
    ] as const;
    }

    
export const getJobsStatusQueryOptions = <TData = Awaited<ReturnType<typeof jobsStatus>>, TError = unknown>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof jobsStatus>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getJobsStatusQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof jobsStatus>>> = ({ signal }) => jobsStatus(id, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof jobsStatus>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type JobsStatusQueryResult = NonNullable<Awaited<ReturnType<typeof jobsStatus>>>
export type JobsStatusQueryError = unknown


export function useJobsStatus<TData = Awaited<ReturnType<typeof jobsStatus>>, TError = unknown>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof jobsStatus>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof jobsStatus>>,
          TError,
          Awaited<ReturnType<typeof jobsStatus>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useJobsStatus<TData = Awaited<ReturnType<typeof jobsStatus>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof jobsStatus>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof jobsStatus>>,
          TError,
          Awaited<ReturnType<typeof jobsStatus>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useJobsStatus<TData = Awaited<ReturnType<typeof jobsStatus>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof jobsStatus>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useJobsStatus<TData = Awaited<ReturnType<typeof jobsStatus>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof jobsStatus>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getJobsStatusQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}
